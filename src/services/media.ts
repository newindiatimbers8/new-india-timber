/**
 * Media and Asset Management Service
 * Handles file uploads, optimization, and asset management
 */

import {
  MediaAsset,
  MediaVariant,
  MediaUploadRequest,
  MediaSearchFilters,
  MediaAnalytics,
  MediaType,
  MediaCategory,
  MediaSize,
  MediaFormat,
  validateMediaAsset,
  validateMediaUpload,
  getMediaTypeFromMimeType,
  generateFileName,
  getOptimizedVariants,
  MEDIA_VALIDATION
} from '@/types/media';
import { loadCollection, saveCollection } from '@/utils/dataLoader';

const MEDIA_COLLECTION = 'media-assets';

// In-memory cache
let mediaCache: MediaAsset[] | null = null;
let cacheTimestamp: number = 0;
const CACHE_DURATION = 10 * 60 * 1000; // 10 minutes

/**
 * Upload media file
 */
export async function uploadMediaFile(
  file: File,
  category: MediaCategory,
  altText: string,
  options: {
    caption?: string;
    title?: string;
    userId?: string;
  } = {}
): Promise<MediaAsset> {
  try {
    // Validate file
    const validationErrors = validateMediaUpload(file);
    if (validationErrors.length > 0) {
      throw new Error(`File validation failed: ${validationErrors.join(', ')}`);
    }

    // Generate unique filename
    const extension = file.name.split('.').pop()?.toLowerCase() || '';
    const filename = generateFileName(file.name, `upload_${Date.now()}`);

    // Determine media type
    const mimeType = file.type;
    const mediaType = getMediaTypeFromMimeType(mimeType);

    // Create file path (simplified - in production, this would upload to cloud storage)
    const path = `media/${category}/${filename}`;

    // Create asset record
    const now = new Date().toISOString();
    const newAsset: MediaAsset = {
      id: generateAssetId(),
      filename,
      path,
      url: `/media/${filename}`, // Simplified URL
      mimeType,
      size: file.size,
      type: mediaType,
      category,
      altText,
      caption: options.caption,
      title: options.title,
      aiGenerated: false, // This would be set if generated by AI
      optimized: false, // This would be set after optimization
      variants: [],
      usage: [],
      downloadCount: 0,
      createdAt: now,
      updatedAt: now
    };

    // Validate asset
    const assetErrors = validateMediaAsset(newAsset);
    if (assetErrors.length > 0) {
      throw new Error(`Asset validation failed: ${assetErrors.join(', ')}`);
    }

    // In a real implementation, you would:
    // 1. Upload file to cloud storage (AWS S3, Cloudinary, etc.)
    // 2. Generate optimized variants
    // 3. Update the asset record with real URLs

    // For this demo, we'll simulate the file upload
    console.log(`Simulating upload of ${filename} (${(file.size / 1024).toFixed(1)} KB)`);

    // Generate optimized variants (simulated)
    newAsset.variants = getOptimizedVariants(newAsset);
    newAsset.optimized = true;

    // Save to storage
    const assets = await loadMediaAssets();
    const updatedAssets = [...assets, newAsset];
    await saveCollection(MEDIA_COLLECTION, updatedAssets);

    // Invalidate cache
    mediaCache = null;

    return newAsset;

  } catch (error) {
    console.error('Error uploading media file:', error);
    throw error;
  }
}

/**
 * Get media assets with filtering
 */
export async function getMediaAssets(filters: MediaSearchFilters = {}): Promise<MediaAsset[]> {
  try {
    let assets = await loadMediaAssets();

    // Apply filters
    if (filters.type) {
      assets = assets.filter(asset => asset.type === filters.type);
    }

    if (filters.category) {
      assets = assets.filter(asset => asset.category === filters.category);
    }

    if (filters.aiGenerated !== undefined) {
      assets = assets.filter(asset => asset.aiGenerated === filters.aiGenerated);
    }

    if (filters.optimized !== undefined) {
      assets = assets.filter(asset => asset.optimized === filters.optimized);
    }

    if (filters.dateFrom) {
      const fromDate = new Date(filters.dateFrom);
      assets = assets.filter(asset => new Date(asset.createdAt) >= fromDate);
    }

    if (filters.dateTo) {
      const toDate = new Date(filters.dateTo);
      assets = assets.filter(asset => new Date(asset.createdAt) <= toDate);
    }

    if (filters.search) {
      const searchTerm = filters.search.toLowerCase();
      assets = assets.filter(asset =>
        asset.filename.toLowerCase().includes(searchTerm) ||
        asset.altText.toLowerCase().includes(searchTerm) ||
        (asset.caption && asset.caption.toLowerCase().includes(searchTerm)) ||
        (asset.title && asset.title.toLowerCase().includes(searchTerm))
      );
    }

    // Sort by creation date (newest first)
    assets.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    return assets;

  } catch (error) {
    console.error('Error getting media assets:', error);
    return [];
  }
}

/**
 * Get media asset by ID
 */
export async function getMediaAssetById(id: string): Promise<MediaAsset | null> {
  try {
    const assets = await loadMediaAssets();
    return assets.find(asset => asset.id === id) || null;
  } catch (error) {
    console.error('Error getting media asset by ID:', error);
    return null;
  }
}

/**
 * Update media asset
 */
export async function updateMediaAsset(id: string, updates: Partial<MediaAsset>): Promise<MediaAsset | null> {
  try {
    const assets = await loadMediaAssets();
    const assetIndex = assets.findIndex(asset => asset.id === id);

    if (assetIndex === -1) return null;

    const existingAsset = assets[assetIndex];
    const updatedAsset: MediaAsset = {
      ...existingAsset,
      ...updates,
      updatedAt: new Date().toISOString()
    };

    // Validate updates
    const errors = validateMediaAsset(updatedAsset);
    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.join(', ')}`);
    }

    assets[assetIndex] = updatedAsset;
    await saveCollection(MEDIA_COLLECTION, assets);

    // Invalidate cache
    mediaCache = null;

    return updatedAsset;

  } catch (error) {
    console.error('Error updating media asset:', error);
    throw error;
  }
}

/**
 * Delete media asset
 */
export async function deleteMediaAsset(id: string): Promise<boolean> {
  try {
    const assets = await loadMediaAssets();
    const filteredAssets = assets.filter(asset => asset.id !== id);

    if (filteredAssets.length === assets.length) {
      return false; // Asset not found
    }

    // In a real implementation, you would also delete the file from storage
    console.log(`Simulating deletion of media asset ${id}`);

    await saveCollection(MEDIA_COLLECTION, filteredAssets);

    // Invalidate cache
    mediaCache = null;

    return true;

  } catch (error) {
    console.error('Error deleting media asset:', error);
    return false;
  }
}

/**
 * Track asset usage
 */
export async function trackAssetUsage(assetId: string, contentId: string, contentType: string): Promise<void> {
  try {
    const asset = await getMediaAssetById(assetId);
    if (!asset) return;

    const usageEntry = `${contentType}:${contentId}`;
    if (!asset.usage.includes(usageEntry)) {
      const updatedUsage = [...asset.usage, usageEntry];
      await updateMediaAsset(assetId, { usage: updatedUsage });
    }

  } catch (error) {
    console.error('Error tracking asset usage:', error);
    // Don't throw - usage tracking failures shouldn't break the app
  }
}

/**
 * Get asset analytics
 */
export async function getAssetAnalytics(assetId: string): Promise<MediaAnalytics | null> {
  try {
    const asset = await getMediaAssetById(assetId);
    if (!asset) return null;

    // Generate mock analytics (in production, this would come from analytics service)
    return {
      assetId,
      views: asset.usage.length * Math.floor(Math.random() * 10) + 5, // Estimate based on usage
      downloads: asset.downloadCount,
      lastAccessed: asset.updatedAt,
      topReferrers: [
        { source: 'blog posts', views: asset.usage.filter(u => u.startsWith('blog:')).length },
        { source: 'products', views: asset.usage.filter(u => u.startsWith('product:')).length },
        { source: 'other', views: asset.usage.filter(u => !u.startsWith('blog:') && !u.startsWith('product:')).length }
      ]
    };

  } catch (error) {
    console.error('Error getting asset analytics:', error);
    return null;
  }
}

/**
 * Optimize media asset
 */
export async function optimizeMediaAsset(assetId: string): Promise<MediaAsset | null> {
  try {
    const asset = await getMediaAssetById(assetId);
    if (!asset || asset.optimized) return asset;

    // In a real implementation, this would:
    // 1. Process the image/video for optimization
    // 2. Generate multiple sizes/formats
    // 3. Update storage with optimized versions

    console.log(`Simulating optimization of ${asset.filename}`);

    const optimizedVariants = getOptimizedVariants(asset);
    const updatedAsset: MediaAsset = {
      ...asset,
      optimized: true,
      variants: optimizedVariants,
      updatedAt: new Date().toISOString()
    };

    return await updateMediaAsset(assetId, updatedAsset);

  } catch (error) {
    console.error('Error optimizing media asset:', error);
    return null;
  }
}

/**
 * Get storage usage statistics
 */
export async function getStorageUsageStats(): Promise<{
  totalAssets: number;
  totalSize: number;
  byType: Record<MediaType, { count: number; size: number }>;
  byCategory: Record<MediaCategory, { count: number; size: number }>;
  optimizedPercentage: number;
}> {
  try {
    const assets = await loadMediaAssets();

    const stats = {
      totalAssets: assets.length,
      totalSize: assets.reduce((sum, asset) => sum + asset.size, 0),
      byType: {} as Record<MediaType, { count: number; size: number }>,
      byCategory: {} as Record<MediaCategory, { count: number; size: number }>,
      optimizedPercentage: 0
    };

    // Group by type and category
    assets.forEach(asset => {
      // By type
      if (!stats.byType[asset.type]) {
        stats.byType[asset.type] = { count: 0, size: 0 };
      }
      stats.byType[asset.type].count++;
      stats.byType[asset.type].size += asset.size;

      // By category
      if (!stats.byCategory[asset.category]) {
        stats.byCategory[asset.category] = { count: 0, size: 0 };
      }
      stats.byCategory[asset.category].count++;
      stats.byCategory[asset.category].size += asset.size;
    });

    // Calculate optimization percentage
    const optimizedCount = assets.filter(asset => asset.optimized).length;
    stats.optimizedPercentage = assets.length > 0 ? (optimizedCount / assets.length) * 100 : 0;

    return stats;

  } catch (error) {
    console.error('Error getting storage usage stats:', error);
    return {
      totalAssets: 0,
      totalSize: 0,
      byType: {} as any,
      byCategory: {} as any,
      optimizedPercentage: 0
    };
  }
}

/**
 * Clean up unused assets
 */
export async function cleanupUnusedAssets(dryRun = true): Promise<{
  found: number;
  wouldDelete: number;
  deleted?: number;
  errors?: string[];
}> {
  try {
    const assets = await loadMediaAssets();
    const result = {
      found: assets.length,
      wouldDelete: 0,
      ...(dryRun ? {} : { deleted: 0, errors: [] as string[] })
    };

    // In a real implementation, you would check which assets are not referenced
    // For this demo, we'll just return mock results
    result.wouldDelete = Math.floor(assets.length * 0.1); // Assume 10% are unused

    if (!dryRun) {
      // Simulate deletion
      result.deleted = result.wouldDelete;
      result.errors = []; // No errors in simulation
    }

    return result;

  } catch (error) {
    console.error('Error cleaning up unused assets:', error);
    throw error;
  }
}

// Private helper functions

async function loadMediaAssets(): Promise<MediaAsset[]> {
  const now = Date.now();
  if (mediaCache && (now - cacheTimestamp) < CACHE_DURATION) {
    return mediaCache;
  }

  const assets = await loadCollection<MediaAsset>(MEDIA_COLLECTION);
  mediaCache = assets;
  cacheTimestamp = now;

  return assets;
}

function generateAssetId(): string {
  return `media_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}