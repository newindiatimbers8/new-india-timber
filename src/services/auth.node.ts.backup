/**
 * Authentication Service
 * Handles user authentication, JWT tokens, and role-based access control
 */

import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import type { 
  UserAccount, 
  AdminProfile, 
  LoginRequest, 
  LoginResponse, 
  UserProfile,
  JWTPayload,
  UserRole,
  Permission,
  PERMISSIONS
} from '@/types/auth';
import { storageService } from './storage';

const JWT_SECRET = process.env.JWT_SECRET || 'timber-craft-secret-key-development';
const JWT_EXPIRES_IN = '24h';
const SALT_ROUNDS = 10;

// Rate limiting storage
const loginAttempts = new Map<string, { count: number; lastAttempt: Date; blockUntil?: Date }>();
const MAX_LOGIN_ATTEMPTS = 5;
const BLOCK_DURATION = 15 * 60 * 1000; // 15 minutes

export class AuthService {
  // Login attempts and rate limiting
  async getLoginAttempts(email: string): Promise<number> {
    const attempts = loginAttempts.get(email);
    if (!attempts) return 0;
    
    // Check if block has expired
    if (attempts.blockUntil && attempts.blockUntil < new Date()) {
      loginAttempts.delete(email);
      return 0;
    }
    
    return attempts.count;
  }

  async recordLoginAttempt(email: string, success: boolean): Promise<void> {
    if (success) {
      // Clear attempts on successful login
      loginAttempts.delete(email);
      
      // Update last login time
      const user = await storageService.findBy<UserAccount>('users', 'email', email);
      if (user) {
        await storageService.update('users', user.id, {
          lastLoginAt: new Date().toISOString(),
        });
      }
    } else {
      const attempts = loginAttempts.get(email) || { count: 0, lastAttempt: new Date() };
      attempts.count += 1;
      attempts.lastAttempt = new Date();
      
      // Block user if too many attempts
      if (attempts.count >= MAX_LOGIN_ATTEMPTS) {
        attempts.blockUntil = new Date(Date.now() + BLOCK_DURATION);
      }
      
      loginAttempts.set(email, attempts);
    }
  }

  async isLoginBlocked(email: string): Promise<boolean> {
    const attempts = loginAttempts.get(email);
    if (!attempts) return false;
    
    if (attempts.blockUntil && attempts.blockUntil > new Date()) {
      return true;
    }
    
    return attempts.count >= MAX_LOGIN_ATTEMPTS;
  }

  // Password management
  async hashPassword(plainPassword: string): Promise<string> {
    return bcrypt.hash(plainPassword, SALT_ROUNDS);
  }

  async verifyPassword(plainPassword: string, hashedPassword: string): Promise<boolean> {
    return bcrypt.compare(plainPassword, hashedPassword);
  }

  // JWT token management
  private generateToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
  }

  private verifyToken(token: string): JWTPayload | null {
    try {
      const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload;
      return decoded;
    } catch (error) {
      return null;
    }
  }

  // Session management
  async createSession(userProfile: UserProfile): Promise<{
    token: string;
    userId: string;
    role: UserRole;
    expiresAt: string;
    issuedAt: string;
  }> {
    const now = Math.floor(Date.now() / 1000);
    const expiresAt = now + (24 * 60 * 60); // 24 hours
    
    const token = this.generateToken({
      userId: userProfile.id,
      email: userProfile.email,
      role: userProfile.role,
    });

    return {
      token,
      userId: userProfile.id,
      role: userProfile.role,
      expiresAt: new Date(expiresAt * 1000).toISOString(),
      issuedAt: new Date(now * 1000).toISOString(),
    };
  }

  async validateSession(token: string): Promise<{
    valid: boolean;
    userId?: string;
    role?: UserRole;
    email?: string;
    expiresAt?: string;
    error?: string;
  }> {
    const payload = this.verifyToken(token);
    
    if (!payload) {
      return { valid: false, error: 'INVALID_TOKEN' };
    }

    // Check if token is expired
    const now = Math.floor(Date.now() / 1000);
    if (payload.exp < now) {
      return { valid: false, error: 'TOKEN_EXPIRED' };
    }

    return {
      valid: true,
      userId: payload.userId,
      role: payload.role,
      email: payload.email,
      expiresAt: new Date(payload.exp * 1000).toISOString(),
    };
  }

  // Authentication methods
  async login(loginRequest: LoginRequest): Promise<LoginResponse> {
    const { email, password } = loginRequest;

    // Basic validation
    if (!email || !email.includes('@')) {
      return {
        success: false,
        error: {
          code: 'INVALID_EMAIL',
          message: 'Please provide a valid email address',
        },
      };
    }

    if (!password) {
      return {
        success: false,
        error: {
          code: 'MISSING_PASSWORD',
          message: 'Password is required',
        },
      };
    }

    // Check if login is blocked
    if (await this.isLoginBlocked(email)) {
      return {
        success: false,
        error: {
          code: 'LOGIN_BLOCKED',
          message: 'Too many failed login attempts. Please try again later.',
        },
      };
    }

    // Find user
    const user = await storageService.findBy<UserAccount>('users', 'email', email);
    
    if (!user) {
      await this.recordLoginAttempt(email, false);
      return {
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password',
        },
      };
    }

    // Verify password
    const isValidPassword = await this.verifyPassword(password, user.passwordHash);
    
    if (!isValidPassword) {
      await this.recordLoginAttempt(email, false);
      return {
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password',
        },
      };
    }

    // Check user status
    if (user.status !== 'active') {
      return {
        success: false,
        error: {
          code: 'ACCOUNT_INACTIVE',
          message: 'Account is not active. Please contact support.',
        },
      };
    }

    // Successful login
    await this.recordLoginAttempt(email, true);

    const userProfile: UserProfile = {
      id: user.id,
      name: user.name,
      email: user.email,
      role: user.role,
      status: user.status,
      lastLoginAt: user.lastLoginAt,
    };

    const session = await this.createSession(userProfile);

    return {
      success: true,
      token: session.token,
      user: userProfile,
      expiresAt: session.expiresAt,
    };
  }

  async logout(token: string): Promise<{
    success: boolean;
    message?: string;
    error?: { code: string; message: string };
  }> {
    const sessionInfo = await this.validateSession(token);
    
    if (!sessionInfo.valid) {
      return {
        success: false,
        error: {
          code: 'INVALID_TOKEN',
          message: 'Invalid or expired token',
        },
      };
    }

    // In a more sophisticated system, you'd add the token to a blacklist
    // For now, we'll just return success since JWT tokens expire naturally
    return {
      success: true,
      message: 'Logged out successfully',
    };
  }

  async getCurrentUser(token: string): Promise<UserProfile | null> {
    const sessionInfo = await this.validateSession(token);
    
    if (!sessionInfo.valid || !sessionInfo.userId) {
      return null;
    }

    const user = await storageService.get<UserAccount>('users', sessionInfo.userId);
    
    if (!user) {
      return null;
    }

    return {
      id: user.id,
      name: user.name,
      email: user.email,
      role: user.role,
      status: user.status,
      lastLoginAt: user.lastLoginAt,
    };
  }

  async refreshToken(currentToken: string): Promise<{
    success: boolean;
    token?: string;
    expiresAt?: string;
    error?: { code: string; message: string };
  }> {
    const sessionInfo = await this.validateSession(currentToken);
    
    if (!sessionInfo.valid) {
      return {
        success: false,
        error: {
          code: 'INVALID_TOKEN',
          message: 'Invalid or expired token',
        },
      };
    }

    const user = await this.getCurrentUser(currentToken);
    
    if (!user) {
      return {
        success: false,
        error: {
          code: 'USER_NOT_FOUND',
          message: 'User not found',
        },
      };
    }

    const newSession = await this.createSession(user);

    return {
      success: true,
      token: newSession.token,
      expiresAt: newSession.expiresAt,
    };
  }

  // User profile management
  async getUserProfile(userId: string): Promise<(UserProfile & { adminProfile?: AdminProfile }) | null> {
    const user = await storageService.get<UserAccount>('users', userId);
    
    if (!user) {
      return null;
    }

    const profile: UserProfile = {
      id: user.id,
      name: user.name,
      email: user.email,
      role: user.role,
      status: user.status,
      lastLoginAt: user.lastLoginAt,
    };

    // If user is admin, include admin profile
    if (user.role === 'admin') {
      const adminProfile = await storageService.findBy<AdminProfile>('admin-profiles', 'userId', userId);
      if (adminProfile) {
        return { ...profile, adminProfile };
      }
    }

    return profile;
  }

  // Role-based access control
  hasPermission(role: UserRole, permission: Permission): boolean {
    switch (role) {
      case 'admin':
        return true; // Admin has all permissions
      case 'editor':
        return ['products', 'blog', 'orders'].includes(permission);
      case 'visitor':
      default:
        return false; // Visitors have no admin permissions
    }
  }

  // Utility method for checking roles
  hasRole(userRole: UserRole, requiredRole: UserRole): boolean {
    const roleHierarchy: Record<UserRole, number> = {
      visitor: 0,
      editor: 1,
      admin: 2,
    };

    return roleHierarchy[userRole] >= roleHierarchy[requiredRole];
  }
}

// Export singleton instance
export const authService = new AuthService();

// Export individual methods for compatibility with contract tests
export const login = (loginRequest: LoginRequest) => authService.login(loginRequest);
export const logout = (token: string) => authService.logout(token);
export const getCurrentUser = (token: string) => authService.getCurrentUser(token);
export const refreshToken = (token: string) => authService.refreshToken(token);
export const hasPermission = (role: UserRole, permission: Permission) => authService.hasPermission(role, permission);
export const getUserProfile = (userId: string) => authService.getUserProfile(userId);
export const createSession = (userProfile: UserProfile) => authService.createSession(userProfile);
export const validateSession = (token: string) => authService.validateSession(token);
export const hashPassword = (password: string) => authService.hashPassword(password);
export const verifyPassword = (password: string, hash: string) => authService.verifyPassword(password, hash);
export const getLoginAttempts = (email: string) => authService.getLoginAttempts(email);
export const recordLoginAttempt = (email: string, success: boolean) => authService.recordLoginAttempt(email, success);
export const isLoginBlocked = (email: string) => authService.isLoginBlocked(email);

export default authService;